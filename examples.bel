(cons 'a 'b '(c d e))

(cons \h "ello")

(2 '(a b c))

(set w '(a (b c) d (e f)))

(find pair w)

(pop (find pair w))

(dedup:sort < "abracadabra")

; need to change parser to cope with symbols starting with .
;(+ .05 19/20)

(map (upon 2 3) (list + - * /))

(let x 'a
  (cons x 'b))

(with (x 1 y 2)
  (+ x y))

(let ((x y) . z) '((a b) c)
  (list x y z))

((fn (x) (cons x 'b)) 'a)

((fn (x|symbol) (cons x 'b)) 'a)

((fn (x|int) (cons x 'b)) 'a)

((fn (f x|f) (cons x 'b)) sym 'a)

((macro (v) `(set ,v 7)) x)

(let m (macro (x) (sym (append (nom x) "ness")))
  (set (m good) 10))

(apply or '(t nil))

(best (of > len) '((a b) (a b c d) (a) (a b c)))

(!3 (part + 2))

(to "testfile" (print 'hello))

(from "testfile" (read))

(set y (table))

(set y!a 1 y!b 2)

(map y '(a b))

(map ++:y '(a b))

y!b

(set z (array '(2 2) 0))

(z 1 1)

(for x 1 2
  (for y 1 2
    (set (z x y) (+ (* x 10) y))))

(z 1 1)

(swap (z 1) (z 2))

(z 1 1)

(def part (f . args)
  (fn rest
    (apply f (append args rest))))

(def insert (f x ys)
  (if (no ys)        (list x)
      (f x (car ys)) (cons x ys)
                     (cons (car ys) (insert f x (cdr ys)))))

(def sort (f xs)
  (foldr (part insert f) nil (rev xs)))

(mac pop (place)
  `(let (cell loc) (where ,place)
     (let xs ((case loc a car d cdr) cell)
       ((case loc a xar d xdr) cell (cdr xs))
       (car xs))))
